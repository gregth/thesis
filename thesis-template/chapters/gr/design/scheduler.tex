\section{Kubernetes Scheduler}
\RestyleAlgo{ruled}

Σε αυτήν την ενότητα, θα παρουσιάσουμε συνοπτικά τη τρέχουσα σχεδίαση του
Kubernetes Scheduler, θα επισημάνουμε τις ελλείψεις που υπάρχουν και θα
προτείνουμε βελτιώσεις που επιλύουν τους τρέχοντες περιορισμούς.

\subsection{To Πρόσθετο VolumeBinding}

Για λόγους συντομίας, στο ελληνικό τμήμα της διπλωματικής παρουσιάζουμε μόνο τη
σχεδίαση της \co{Filter} και της \co{PreBind}  φάσης του προσθέτου, καθώς
σχετίζεται άμεσα με τις προτεινόμενες επεκτάσεις. Για την αναλυτική παρουσίαση
των υπολοίπων φάσεων του προσθέτου, μπορείτε να ανατρέξετε στο αντίστοιχο
αγγλικό κεφάλαιο, στην ενότητα \ref{section:design-volume-binding}.

\subsection*{PreFilter Φάση}

\co{Filter}: αξιολογεί αν ένα Pod μπορεί να τοποθετηθεί σε έναν κόμβο, βάσει των
τόμων που ζητά, τόσο για τα δεσμευμένα όσο και για τα μη δεσμευμένα PVC:
\begin{itemize}
      \tightlist
      \item Για τα \textit{δεσμευμένα PVC}, ελέγχει ότι το PV του κάθε PVC είναι
            προσβάσιμο (βάσει τoy node affinity που φέρει) από τον εξεταζόμενο
            κόμβο.
      \item Για τα \textit{μη δεσμευμένα PVC}, προσπαθεί να βρει διαθέσιμα PVs
            που μπορούν να ικανοποιήσουν τις απαιτήσεις του PVC και που είναι
            προσβάσιμα (βάσει του node affinity τους) από τον εξεταζόμενο κόμβο.
            Τα PVCs για τα οποία δεν κατάφερε να βρει κατάλληλα PVs, θα τα
            αποκαλούμε εφεξής ``\textit{PVCs to provision}''.
      \item Για κάθε \textit{PVC to provision}, ελέγχει αν η \co{StorageClass}
            του PVC υποστηρίζει τη δυναμική παροχή και αν υπάρχει αρκετή
            χωρητικότητα αποθήκευσης προσβάσιμη από τον κόμβο. Εάν όχι, το Pod
            δεν μπορεί να ανατεθεί στον κόμβο. Αυτό είναι το βήμα όπου
            η χωρητικότητα αποθήκευσης λαμβάνεται υπόψη.

\end{itemize}

Η τρέχουσα υλοποίηση του χρονοδρομολογητή, ελέγχει αν υπάρχει αρκετή
χωρητικότητα για κάθε PVC to provision, καλώντας τη μέθοδο \co{hasEnough()} με
ένα μόνο PVC ως είσοδο. Ζητά από τον  API Server όλα τα αντικείμενα
\co{CSIStorageCapacity}. και ελέγχει αν κάποιο από αυτά ταιριάζει με το
\co{StorageClass} του PVC, είναι προσβάσιμο από τον εξεταζόμενο κόμβο και η
αναφερόμενη χωρητικότητα του αντικειμένου είναι μεγαλύτερη από τη ζητούμενη
χωρητικότητα του PVC. Εάν ένα τέτοιο CSIStorageCapacity υπάρχει, υπάρχει αρκετός
χώρος στον κόμβο για τη δυναμική παροχή τόμου για το εξεταζόμενο PVC.

Είναι σημαντικό να επισημάνουμε ότι δεν ελεγχει αν υπάρχει αποθηκευτικός χώρος
συνολικά για όλα τα PVCs, αλλά μόνο αν το κάθε PVC χωριστά χωράει σε έναν κόμβο.

\subsection*{PreBind Φάση}

Η φάση \co{PreBind} εκτελείται αφού ο χρονοδρομολογητής έχει επιλέξει έναν κόμβο
για  το Pod.

Για κάθε ένα από τα \textit{μη δεσμευμένα PVC} που το πρόσθετο βρήκε ένα
κατάλληλο PV κατά τη διάρκεια της φάσης \co{Filter}, θα ενημερώσει τον API
Server με τη δέσμευση, δηλαδή, θα ενημερώσει το αντίστοιχο PV ώστε να δείχνει
στο PVC, και στη συνέχεια, ο ελεγκτής Kubernetes PersistentVolume θα ολοκληρώσει
την αμφίδρομη δέσμευση.

Για κάθε ένα από τα \textit{PVCs to provision}, θα ενημερώσει τα αντίστοιχα PVCs
στον API Server με το  ``selected node annotation'' \footnote{Το selected node
annotation: \co{volume.kubernetes.io/selected-node}} για να σηματοδοτήσει στον
\en{external provisioner} ότι ένας τόμος για το PVC πρέπει να δημιουργηθεί δυναμικά
σε ένα τμήμα τοπολογίας που είναι προσβάσιμο από τον κόμβο που υποδεικνύει η
σημείωση. 

Στη συνέχεια, το πρόσθετο θα κάνει poll τον API Server έως ότου όλα τα PVCs
δεσμευτούν  PVs. Εάν το selected node annotation κάποιου PVC to provision
αφαιρεθεί, θα ακυρώσει την τρέχουσα προσπάθεια χρονοδρομολόγησης και θα
καλέσει τα πρόσθετα \co{Unreserve}.Η αφαίρεση του annotation είναι ένας
μηχανισμός με τον οποίο ο external provisioner ουσιαστικά ειδοποιεί τον
χρονοδρομολογητή ότι απέτυχε η παροχή του τόμου και θα πρέπει να δοκιμάσει ξανά,
ενδεχομένως σε άλλον κόμβο.


\subsection{Ελλείψεις \& Προτεινόμενες Επεκτάσεις}

Σύμφωνα με την προηγούμενη ανάλυση των αλγορίθμων, ο τρέχων σχεδιασμός του
Kubernetes Scheduler έχει τους ακόλουθους περιορισμούς:

\begin{enumerate}
      \item Η μέθοδος \texttt{Filter} του πρόσθετου VolumeBinding χρησιμοποιεί
            τα αντικείμενα \en{CSIStorageCapacity} του Kubernetes API για να
            αντλήσει πληροφορίες για τον διαθέσιμο αποθηκευτικό χώρο. Αυτό το
            αντικείμενο API έγινε beta στην έκδοση Kubernetes 1.21 και ήταν σε
            κατάσταση alpha σε προηγούμενες εκδόσεις. Οι κύριοι πάροχοι
            υπηρεσιών νέφους δεν ενεργοποιούν τα χαρακτηριστικά σε κατάσταση
            alpha στις υπηρεσίες τους. Ως αποτέλεσμα, τα CSIStorageCapacity
            αντικείμενα δεν είναι ενεργοποιημένα σε συστοιχίες που εκτελούν
            εκδόσεις προγενέστερες της 1.21 στους περισσότερους παρόχους cloud.
            Αυτό είναι ένα σημαντικό πρόβλημα, δεδομένου ότι πολλές επιχειρήσεις
            (συμπεριλαμβανομένων των πελατών μας) δεν τρέχουν τις τελευταίες
            εκδόσεις του Kubernetes για λόγους σταθερότητας. Στη δική μας
            περίπτωση, οι πελάτες μας εκτελούν συστοιχίες Kubernetes 1.19 και
            1.20 και χρειάζονταν τη δυνατότητα χρονοδρομολόγησης Pods με εξέταση
            της τοπικής αποθήκευσης.
      \item Η τρέχουσα σχεδιαστική λογική της φάσης \co{Filter} του πρόσθετου
            \co{VolumeBinding} δεν λαμβάνει υπόψη της τον αποθηκευτικό χώρο που
            απαιτείται για την παροχή πολλαπλών PVC ενός Pod. Αντ' αυτού,
            ελέγχει αν κάθε μεμονωμένο PVC μπορεί να δημιουργηθεί στον
            αποθηκευτικό χώρο που είναι προσβάσιμος από τον κόμβο, χωρίς να
            διασφαλίζει ότι υπάρχει αρκετός χώρος για όλα αυτά ταυτόχρονα. Αυτό
            είναι ένα κρίσιμο πρόβλημα: σε περίπτωση που ένα Pod αναφέρεται σε
            πολλαπλά μη δεσμευμένα PVC και δεν υπάρχει αρκετός χώρος για όλα
            αυτά, ένα από αυτά γίνει provision και η παροχή των υπολοίπων θα
            αποτύχει, τότε όλες οι μελλοντικές αποφάσεις χρονοδρομολόγησης θα
            περιορίζονται από το ήδη δημιουργημένο τόμο και το Pod θα κολλήσει.
\end{enumerate}

Δεδομένου ότι ο σχεδιασμός του upstream έρχεται με τους προαναφερθέντες
περιορισμούς, προτείνουμε να επεκτείνουμε τον Kubernetes Scheduler και να
εγκαταστήσουμε τον επεκταμένο χρονοδρομολογητή στη συστοιχία. Ο προτεινόμενος
σχεδιασμός μπορεί να χωριστεί στα ακόλουθα μέρη:

% TODO: enumerate or itemize?
\begin{enumerate}
      \tightlist
      \item Επέκταση του Rok CSI Node του οδηγού αποθήκευσης, ώστε να
            αναφέρει τη διαθέσιμη χωρητικότητα κάθε κόμβου ως annotation στο
            αντίστοιχο αντικείμενο \texttt{Node} του Kubernetes.
      \item Επέκταση του Rok CSI Controller του οδηγού αποθήκευσης
            ώστε να απαντά με κατάλληλο σφάλμα στην κλήση \co{CreateVolume} όταν
            η εναπομένουσα χωρητικότητα για την παροχή του τόμου είναι
            ανεπαρκής.
      \item Επέκταση του πρόσθετου VolumeBinding του Kubernetes Scheduler ώστε
            να ελέγχει αν πολλαπλοί τόμοι ενός Pod χωρούν σε έναν κόμβο,
            συγκρίνοντας τη συνολική τους απαίτηση σε χωρητικότητα με την
            αναφερθείσα διαθέσιμη χωρητικότητα.
      \item Εγκατάσταση του επεκταμένου χρονοδρομολογητή στη συστοιχία.
      \item Ανάπτυξη και εγκατάσταση ενός  webhook που θα μεταλλάσσει τα Pods
            ώστε να χρησιμοποιούν τον επεκταμένο χρονοδρομολογητή.
\end{enumerate}

\subsubsection{Επέκταση του Rok CSI Node}

Δεδομένου ότι τα αντικείμενα \co{CSIStorageCapacity} δεν μπορούν να γίνουν
back-port σε προηγούμενες εκδόσεις του Kubernetes και, επίσης, η προσθήκη ενός
παρόμοιου Custom Resource θα απαιτούσε αρκετή προσπάθεια άνευ αιτίας,
αποφασίζουμε να αναφέρουμε τη χωρητικότητα κάθε κόμβου ως annotation στο
αντίστοιχο αντικείμενο Node. Το annotation, το οποίο αποκαλούμε ``annotation
χωρητικότητας'' θα είναι της μορφής
\co{rok.arrikto.com/capacity:<free-storage-bytes>}.

Το πρόσθετο Rok CSI Node του οδηγού αποθήκευσης που εκτελείται σε κάθε κόμβο της
συστοιχίας υπολογίζει περιοδικά τον διαθέσιμο αποθηκευτικό χώρο και ενημερώνει
το annotation χωρητικότητας. Δίνει εντολές στο Logical Volume Manager (LVM) του
κόμβου για να μάθει τον ελεύθερο χώρο του Rok Volume Group και ενημερώνει το
αντίστοιχο \co{Node} αντικείμενο με την τιμή της διαθέσιμης χωρητικότητας.

\subsubsection{Επέκταση του Rok CSI Controler}

Επεκτείνουμε το πρόσθετο Rok CSI Controller του οδηγού αποθήκευσης ώστε να
επιστρέφει το status  code \co{GRPCResourceExhausted} ως απάντηση στην κλήση
\co{CreateVolume} του external provisioner όταν η παροχή ενός τόμου αποτυγχάνει
λόγω ανεπαρκούς χωρητικότητας αποθήκευσης.

\subsubsection{Επέκταση του VolumeBinding Plugin}
\label{section:gr-volume-plugin-extensions}

Προτείνουμε την επέκταση της \co{Filter} μεθόδου του πρόσθετου
\co{VolumeBidning} ως εξής:
\begin{enumerate}
      \tightlist
      \item Κατά τον έλεγχο των PVCs του Pod που χρειάζονται να δημιουργηθούν
            δυναμικά (provision) (μέθοδος \co{checkVolumeProvisions()}), να
            επιλέγει όλα τα Rok PVCs
            \footnote{PVCs provisioned by the \co{rok.arrikto.com}
                  provisioner.} (εφεξής αναφέρονται ως ``\\textit{Rok claims to
                  provision}'') και να ελέγχει αν υπάρχει αρκετή χωρητικότητα
                  για το συνολικό αποθηκευτικό χώρο που ζητούν.
      \item Να ελέγχει αν υπάρχει αρκετή χωρητικότητα για τα Rok claims to
            provision ως εξής:
            \begin{enumerate}
                  \tightlist
                  \item Να υπολογίζει τη συνολική χωρητικότητα που ζητείται
                        αθροίζοντας τα αιτήματά τους.
                  \item Να ελέγχει  αν ο εξεταζόμενος κόμβος διαθέτει annotation
                        χωρητικότητας του Rok \footnote{Το annotation
                        χωρητικότητας του Rok:
                        \texttt{rok.arrikto.com/capacity}} .
                  \item Αν to annotation \textit{δεν υπάρχει}, ή αν υπάρχει αλλά
                        δεν είναι έγκυρος ακέραιος αριθμός, τα Rok claims to
                        provision δεν μπορούν να δημιουργηθούν στον κόμβο. Η
                        απουσία της σημείωσης υποδεικνύει ότι το πρόγραμμα
                        οδήγησης Rok CSI δεν εκτελείται στον κόμβο.
                  \item Εάν υπάρχει το annotation χωρητικότητας, να ελέγχει αν η
                        αναφερόμενη διαθέσιμη χωρητικότητα είναι μεγαλύτερη ή
                        ίση με τη συνολική χωρητικότητα που ζητούν τα Rok claims
                        to provision. Εάν δεν ισχύει η συνθήκη, δεν υπάρχει
                        αρκετή χωρητικότητα, και τα Rok claims to provision δεν
                        μπορούν να δημιουργηθούν στον κόμβο,  οπότε και το Pod
                        δεν μπορεί να προγραμματιστεί στον κόμβο.
            \end{enumerate}
      \item Διατηρούμε της συμβατότητα προς τα πίσω με τη μη τροποποίηση του
            χειρισμού των  PVCs που δεν ζητούν αποθηκευτικό χώρο από την κλάση
            αποθήκευσης Rok. Ο σχεδιασμός μας, διαχωρίζει τα PVCs σε τοπικά Rok
            PVCs και μη Rok PVCs, και επεκτείνει μονάχα τον τρόπο χειρισμού
            μονάχα για τα Rok PVCs. Τα PVC που παρέχονται από άλλους παρόχους
            αποθήκευσης δεν θα επηρεαστούν από τις αλλαγές μας.
\end{enumerate}

% transl: επιπεδο ελέγχου


\subsubsection{Εγκατάσταση του Rok Scheduler}

Ο \co{kube-cheduler} εκτελείται από προεπιλογή σε κάθε πάροχο νέφους ως μέρος
του επιπέδου ελέγχου του Kubernetes και είναι ο προεπιλεγμένος χρονοδρομολογητής
που χρησιμοποιείται για τη χρονοδρομολόγηση των Pods. Οι πάροχοι νέφους
αποκρύπτουν το επίπεδο ελέγχου από τον τελικό χρήστη των υπηρεσιών τους, οπότε
δεν υπάρχει δυνατότητα αντικατάστασης και παραμετροποίησης του εκτελούμενου
χρονοδρομολογητή.

Ως συνέπεια αυτού του περιορισμού, εγκαθιστούμε στη συστοιχία --παράλληλα με τον
προεπιλεγμένο χρονοδρομολογητή--  τον δικό μας χρονοδρομολογητή, που εκτελεί το
επεκταμένο  VolumeBinding πρόσθετο.  Εφεξής θα αναφερόμαστε στον δικό μας
επεκταμένο χρονοδρομολογητή ως ``\textit{Rok Scheduler}''.

\subsubsection{Εγκατάσταση του Rok Scheduler Webhook}

Δεδομένου ότι εγκαθιστούμε τον Rok Scheduler χωρίς να αντικαταστήσουμε το
προεπιλεγμένο Kubernetes Scheduler της συστοιχίας, κάθε Pod πρέπει να καθορίζει
ποιος scheduler θα το χρονοδρομολογήσει ορίζοντας το πεδίο
\co{spec.schedulerName}. Εάν το πεδίο δεν έχει οριστεί, ο προεπιλεγμένος
χρονοδρομολογητής χρησιμοποιείται.

Σίγουρα δεν θέλουμε κάθε χρήστης να ορίζει χειροκίνητα το όνομα του scheduler
στο το Pod - αυτό θα επέτρεπε στους χρήστες να παρακάμψουν την πολιτική
χρονοδρομολόγησης που έχουμε ορίσει, είναι επιρρεπές σε σφάλματα και είναι μια
κουραστική διαδικασία. Χρειαζόμαστε έναν αυτόματο τρόπο για να το πετύχουμε
αυτό. Η λύση για την αυτοματοποίηση της εργασίας, είναι ένα mutating webhook.

Εγκαθιστούμε ένα μεταλλασσόμενο webhook στη συστοιχία, το οποίο στο εξής θα
αναφέρεται ως ``\textit{Rok Scheduler webhook}'', το οποίο δέχεται τα πρόσφατα
δημιουργηθέντα Pods σε συγκεκριμένα namespaces της συστοιχίας και τα
μεταλλάσσει προσθέτοντας το όνομα του Rok Scheduler στο πεδίο
\co{spec.schedulerName}.